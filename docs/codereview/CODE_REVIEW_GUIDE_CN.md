# 代码审查综合指南

> 结合最佳实践和问题分类检测的综合代码审查指南。
> 
> 本文档可供 GitHub Copilot、审查工具和开发团队参考使用。

## 目录

- [概述](#概述)
- [黄金法则](#黄金法则)
- [审查流程指南](#审查流程指南)
- [问题分类速查表](#问题分类速查表)
- [详细分类检查清单](#详细分类检查清单)
- [PR提交检查清单](#pr提交检查清单)
- [使用指南](#使用指南)

---

## 概述

### 目的

代码审查主要有两个目的：
1. **发现缺陷**：测试通常能发现50-60%的问题，而执行良好的代码审查可以发现60-80%的缺陷。
2. **提升质量**：确保软件具备六大关键特性：**可靠性、效率、可用性、可维护性、安全性和可移植性**。

### 范围

审查代码时，需要检查：
- 分配审查的每一行代码
- 逻辑正确性
- 设计决策
- 代码质量和可维护性

---

## 黄金法则

| # | 法则 | 描述 |
|---|------|------|
| 1 | **简单、高效、安全的设计** | 避免过度设计；优先考虑清晰性和安全性 |
| 2 | **严格的完整性和性能** | 确保数据完整性，按需优化 |
| 3 | **合理的模块化** | 模块内高内聚，模块间低耦合 |
| 4 | **减少重复** | DRY原则 - 不要重复自己 |
| 5 | **良好的命名和注释** | 清晰、描述性的名称；有意义的注释 |

### 审查基准

> **目标：每100行代码(LOC)至少发现1个逻辑问题**

---

## 审查流程指南

### 审查前

1. 理解上下文和需求
2. 审查相关文档和设计文档
3. 检查是否包含测试

### 审查中

1. 仔细阅读PR描述
2. 系统性地检查所有变更文件
3. 验证逻辑流程和边界情况
4. 寻找问题模式（见下文分类）
5. 考虑安全影响
6. 检查性能问题

### 审查后

1. 提供建设性反馈
2. 建议具体改进方案
3. 只有在所有关键问题解决后才批准

---

## 问题分类速查表

| 分类 | 代码 | 优先级 | 描述 |
|------|------|--------|------|
| 需求不匹配 | `REQ` | 🔴 关键 | 实现与需求不符 |
| 逻辑问题 | `LOGI` | 🔴 关键 | 阻止正确执行的Bug |
| 安全问题 | `SEC` | 🔴 关键 | 漏洞和安全风险 |
| 认证/授权 | `AUTH` | 🔴 关键 | 访问控制问题 |
| 设计问题 | `DSN` | 🟠 高 | 架构和设计问题 |
| 健壮性 | `RBST` | 🟠 高 | 错误处理和容错 |
| 事务问题 | `TRANS` | 🟠 高 | 数据库事务问题 |
| 并发问题 | `CONC` | 🟠 高 | 多线程问题 |
| 性能问题 | `PERF` | 🟠 高 | 资源效率问题 |
| 兼容性 | `CPT` | 🟡 中 | 版本和环境兼容性 |
| 幂等性 | `IDE` | 🟡 中 | 重复操作安全性 |
| 可维护性 | `MAIN` | 🟡 中 | 长期维护问题 |
| 耦合问题 | `CPL` | 🟡 中 | 模块间依赖 |
| 可读性 | `READ` | 🟢 普通 | 代码清晰度问题 |
| 简洁性 | `SIMPL` | 🟢 普通 | 不必要的复杂性 |
| 一致性 | `CONS` | 🟢 普通 | 风格和命名一致性 |
| 重复代码 | `DUP` | 🟢 普通 | 重复的代码/逻辑 |
| 命名问题 | `NAM` | 🟢 普通 | 变量/函数命名 |
| 文档字符串 | `DOCS` | 🟢 普通 | 文档注释 |
| 注释问题 | `COMM` | 🔵 低 | 行内注释 |
| 日志问题 | `LOGG` | 🔵 低 | 日志语句 |
| 错误消息 | `ERR` | 🔵 低 | 错误定义 |
| 格式问题 | `FOR` | 🔵 低 | 代码格式 |
| 语法问题 | `GRAM` | 🔵 低 | 文本语法问题 |
| 最佳实践 | `PRAC` | 🔵 低 | 规范违反 |
| PR描述 | `PR` | 🔵 低 | PR文档 |

---

## 详细分类检查清单

### 🔴 关键问题

#### 需求不匹配 (REQ)

**定义**：代码实现与需求/文档不符。

**检查清单**：
- [ ] 代码实现与需求/文档一致
- [ ] 所有规定的行为都已实现
- [ ] 需求中的边界情况已处理
- [ ] 考虑了失败路径，不仅仅是"正常路径"
- [ ] 假设条件有文档记录并已验证

**示例**：
```
[REQ] 文档说明为A，但实现为B
[REQ] 定义了"正常路径"，但忽略了失败路径
[REQ] 需求指定30秒超时，但代码使用10秒
```

#### 逻辑问题 (LOGI)

**定义**：任何阻止软件按预期运行的问题。

**检查清单**：
- [ ] 无空指针引用
- [ ] 无除零可能性
- [ ] 数组/列表索引边界已检查
- [ ] 无无限递归可能性
- [ ] 所有if-else分支完整
- [ ] 控制流正确关闭（if-else if有else）
- [ ] 表单/输入数据已验证
- [ ] 循环终止条件正确

**示例**：
```
[LOGI] 未检查user是否为null就访问user.name
[LOGI] if-else if语句缺少else分支处理其他情况
[LOGI] 数组索引访问未进行边界检查
[LOGI] 无限递归导致栈溢出
```

#### 安全问题 (SEC)

**定义**：防止漏洞，保护免受未授权访问、数据泄露、篡改或中断等威胁。

**检查清单**：
- [ ] 无SQL注入漏洞
- [ ] 无XSS（跨站脚本）漏洞
- [ ] 无缓冲区溢出风险
- [ ] 无硬编码凭证或密钥
- [ ] 正确的认证检查
- [ ] 数据库中无明文凭证
- [ ] 安全的数据传输（HTTPS、加密）
- [ ] 所有用户输入都有验证
- [ ] 正确的输出编码

**示例**：
```
[SEC] SQL注入：查询直接拼接用户输入
[SEC] 硬编码凭证：password = "admin123"
[SEC] XSS漏洞：用户输入未转义直接渲染
[SEC] 数据库中存储明文凭证
```

#### 认证/授权 (AUTH)

**定义**：与身份验证和访问控制相关的问题。

**检查清单**：
- [ ] 需要认证的地方都有认证
- [ ] 授权检查到位
- [ ] 基于角色的访问控制正确实现
- [ ] 会话管理安全
- [ ] Token正确验证

**示例**：
```
[AUTH] API端点无需认证即可访问
[AUTH] 管理员功能缺少角色验证
[AUTH] JWT令牌使用前未验证
```

### 🟠 高优先级问题

#### 设计问题 (DSN)

**定义**：设计/实现应该简单、可用、安全、可靠、可维护、可扩展和高效。

**检查清单**：
- [ ] 设计简单直接
- [ ] 设计可用且直观
- [ ] 设计默认安全
- [ ] 设计可靠
- [ ] 设计可维护
- [ ] 设计可扩展
- [ ] 设计高效
- [ ] 工作流不过于复杂

**示例**：
```
[DSN] 设计过于复杂：工作流有不必要的步骤
[DSN] 设计不高效：多次处理数据
[DSN] 设计不灵活：难以扩展新需求
```

#### 健壮性 (RBST)

**定义**：系统在不崩溃的情况下优雅地处理错误、意外输入或压力条件的能力。

**检查清单**：
- [ ] 异常被适当捕获和处理
- [ ] 返回错误时附带上下文（errors.Wrap/Wrapf 等）
- [ ] 关键路径在返回错误前记录 error 日志，便于追踪
- [ ] 无效数据被阻止影响系统
- [ ] 系统在组件故障时继续运行
- [ ] 系统能在故障后恢复到稳定状态
- [ ] 适当的地方实现了优雅降级

**示例**：
```
[RBST] 异常未捕获：网络错误时应用崩溃
[RBST] 无效输入未验证：导致下游错误
[RBST] 外部服务不可用时无回退机制
```

#### 事务问题 (TRANS)

**定义**：事务是作为单个逻辑工作单元执行的操作序列。

**检查清单**：
- [ ] 事务边界正确定义
- [ ] 异常时事务回滚
- [ ] 避免长时间运行的事务
- [ ] 有死锁预防措施
- [ ] 需要数据完整性时使用事务

**示例**：
```
[TRANS] 多步操作缺少事务边界
[TRANS] 异常时事务未回滚
[TRANS] 长时间运行的事务阻塞其他操作
[TRANS] 锁顺序不一致导致死锁风险
```

#### 并发问题 (CONC)

**定义**：特定于多线程/多任务环境中发生的问题。

**检查清单**：
- [ ] 无竞态条件
- [ ] 无死锁可能性
- [ ] 正确使用锁
- [ ] 需要时使用线程安全的数据结构
- [ ] 需要时使用原子操作

**示例**：
```
[CONC] 竞态条件：共享计数器未同步修改
[CONC] 死锁：方法A和B以不同顺序获取锁
[CONC] 多线程环境中使用非线程安全的集合
```

#### 性能问题 (PERF)

**定义**：不必要地过度消耗CPU、内存、磁盘、网络等资源。

**检查清单**：
- [ ] 使用高效算法（检查Big O复杂度）
- [ ] 无过度内存使用
- [ ] 数据库查询已优化
- [ ] 使用批量操作而非逐个处理
- [ ] 数据库查询有适当索引
- [ ] 无不必要的重复操作
- [ ] 适当使用缓存
- [ ] 无N+1查询问题

**示例**：
```
[PERF] 使用O(n²)算法，而O(n log n)是可行的
[PERF] 循环内数据库查询：应使用批量查询
[PERF] 频繁过滤的列缺少索引
[PERF] N+1查询：逐个加载关联实体
```

### 🟡 中优先级问题

#### 兼容性 (CPT)

**定义**：阻止软件与不同版本或环境正确交互的冲突。

**检查清单**：
- [ ] 保持向后兼容性
- [ ] 考虑向前兼容性
- [ ] API变更适当版本化
- [ ] 数据库Schema变更迁移安全
- [ ] 测试浏览器/操作系统兼容性
- [ ] 库版本兼容

**示例**：
```
[CPT] API字段删除破坏现有客户端
[CPT] 新功能与旧浏览器版本不兼容
[CPT] 库升级引入破坏性变更
```

#### 幂等性 (IDE)

**定义**：多次运行操作产生相同结果。

**检查清单**：
- [ ] 重复操作产生相同结果
- [ ] 重试不产生重复记录
- [ ] 删除操作处理已删除的情况
- [ ] 支付/关键操作有幂等键

**示例**：
```
[IDE] 同一订单下单两次产生重复记录
[IDE] 第二次删除返回错误
[IDE] 支付操作无幂等键
```

#### 可维护性 (MAIN)

**定义**：应用程序可被理解、修复或增强的程度。约75%的项目成本是维护！

**检查清单**：
- [ ] 代码具有良好可读性
- [ ] 代码模块化且逻辑分离
- [ ] 复杂度保持较低（无深层嵌套）
- [ ] 代码可测试
- [ ] 文档保持最新
- [ ] 使用一致的编码模式

**示例**：
```
[MAIN] 代码紧密耦合：变更需要修改多个文件
[MAIN] 无单元测试：难以验证变更
[MAIN] 文档过时：不反映当前行为
```

#### 耦合问题 (CPL)

**定义**：软件模块之间的相互依赖程度。期望低耦合高内聚。

**检查清单**：
- [ ] 无硬编码依赖
- [ ] 下层不依赖上层
- [ ] 组件依赖接口而非实现
- [ ] 相关逻辑集中在一处
- [ ] 无隐藏依赖（必须先调用A再调用B）
- [ ] 数据通过定义的接口传递，而非共享结构

**示例**：
```
[CPL] 方法接收整个User对象但只使用userId
[CPL] 必须先调用init()再调用start()，但依赖未记录
[CPL] 业务逻辑分散在多个不相关的模块中
```

### 🟢 普通问题

#### 可读性 (READ)

**定义**：清晰的代码结构、命名约定和文档。

**检查清单**：
- [ ] 变量名具有描述性（不是x1、temp、val2）
- [ ] 函数大小合理（不超过100行）
- [ ] 嵌套有限（最多3-4层）
- [ ] 正确的缩进和间距
- [ ] 简单代码优于"聪明"的技巧
- [ ] 逻辑清晰地分离到函数/模块中

**示例**：
```
[READ] 变量名'd'不清晰，应该是'data'或更具体
[READ] 函数超过150行，应该拆分成更小的函数
[READ] 5层嵌套的if语句，应该重构
```

#### 简洁性 (SIMPL)

**定义**：设计和实现应尽可能简单，避免不必要的复杂性。

**检查清单**：
- [ ] 逻辑直接易懂
- [ ] 每个函数/类有单一职责
- [ ] 无过度设计或投机性功能
- [ ] 删除未使用的代码和注释
- [ ] 无不必要的通用设计

**示例**：
```
[SIMPL] 简单问题使用过于通用的解决方案
[SIMPL] 未使用的辅助函数应删除
[SIMPL] 过早优化使代码难以理解
```

#### 一致性 (CONS)

**定义**：确保文档、命名、格式、逻辑、注释、日志等的一致性。

**检查清单**：
- [ ] 一致的命名约定（camelCase、snake_case等）
- [ ] 注释语言一致
- [ ] 代码和注释同步
- [ ] 代码和文档同步
- [ ] 全文术语一致

**示例**：
```
[CONS] 随意混用camelCase和snake_case
[CONS] 代码变了但注释仍描述旧行为
[CONS] 代码和文档中对同一概念使用不同术语
```

#### 重复代码 (DUP)

**定义**：不同位置的重复代码/逻辑导致高耦合和低可维护性。

**检查清单**：
- [ ] 无复制粘贴的代码块
- [ ] 重复表达式提取为变量
- [ ] 公共逻辑提取为函数
- [ ] 共享代码放在适当的工具类/辅助类中

**示例**：
```
[DUP] 相同的验证逻辑在3个不同的地方复制粘贴
[DUP] 重复表达式cameras[i].getStream().getResolution()应提取为变量
```

#### 命名问题 (NAM)

**定义**：名称应清晰、描述性但简洁、易于理解。

**检查清单**：
- [ ] 名称清晰且具有描述性
- [ ] 名称简洁（不超过5个词）
- [ ] 避免模糊词如"data"、"info"、"stuff"
- [ ] 数组/列表使用复数名称（cameras、cameraList）
- [ ] 方法使用动词，类使用名词
- [ ] 布尔变量命名为疑问形式（isActive、hasPermission）

**示例**：
```
[NAM] 变量'tp'太晦涩，应该是'timeoutPeriod'
[NAM] 数组'camera'应该是'cameras'或'cameraList'
[NAM] 方法'calculation()'应该是'calculate()'
```

#### 文档字符串 (DOCS)

**定义**：解释函数、类或模块功能的特殊注释。

**检查清单**：
- [ ] 必要时函数/类有文档字符串
- [ ] 参数有说明
- [ ] 返回值有说明
- [ ] 异常/副作用有说明
- [ ] 文档字符串与代码同步

**示例**：
```
[DOCS] 公共API方法缺少文档字符串
[DOCS] 参数'options'未说明
[DOCS] 返回值类型和含义未指定
```

### 🔵 低优先级问题

#### 注释问题 (COMM)

**定义**：应根据需要添加注释以帮助审查和维护。

**检查清单**：
- [ ] 复杂逻辑有解释性注释
- [ ] 变通方案/技巧有上下文注释
- [ ] 无注释掉的死代码
- [ ] 注释清晰简洁
- [ ] 性能权衡有解释

**示例**：
```
[COMM] 复杂算法缺少解释注释
[COMM] 变通方案缺少上下文：为什么需要这样做？
[COMM] 注释掉的代码应删除
```

#### 日志问题 (LOGG)

**定义**：按需记录日志，避免不必要或过多的日志。

**检查清单**：
- [ ] 错误条件有日志
- [ ] 日志包含必要的上下文（ID、类型）
- [ ] 生产环境无过多调试日志
- [ ] 使用适当的日志级别
- [ ] 不记录敏感数据

**示例**：
```
[LOGG] 错误情况未记录日志
[LOGG] 日志消息缺少上下文：缺少请求ID
[LOGG] 调试日志留在生产代码中
```

#### 错误消息 (ERR)

**定义**：根据需要添加或定义错误，包含清晰、简洁的上下文。

**检查清单**：
- [ ] 错误消息具体且有帮助
- [ ] 需要时定义错误代码/类型
- [ ] 错误消息包含上下文
- [ ] 错误被适当记录

**示例**：
```
[ERR] 通用消息"出了点问题"缺少上下文
[ERR] 面向客户端的API缺少错误代码
[ERR] 错误消息未指示应采取的操作
```

#### 格式问题 (FOR)

**定义**：包括编码风格、格式和措辞。

**检查清单**：
- [ ] 无拼写错误
- [ ] 一致的缩进
- [ ] 无过多空行
- [ ] 操作符周围有适当间距
- [ ] 代码符合团队风格指南

**示例**：
```
[FOR] 变量名拼写错误：'recieve'应该是'receive'
[FOR] 缩进不一致：混用制表符和空格
[FOR] 语句之间空行过多
```

#### 语法问题 (GRAM)

**定义**：注释、错误消息和文档应语法正确。

**检查清单**：
- [ ] 注释语法正确
- [ ] 错误消息正确书写
- [ ] 文档句子完整

**示例**：
```
[GRAM] 注释有拼写错误："the user is login"应该是"the user is logged in"
[GRAM] 文档中句子不完整
```

#### 最佳实践 (PRAC)

**定义**：符合编程风格、约定、常见用例和团队约定的规则。

**检查清单**：
- [ ] 事件处理器遵循命名约定（onXxx）
- [ ] 文件按功能/模块组织
- [ ] 文件夹结构遵循约定
- [ ] 无容易造成困惑的模式

**示例**：
```
[PRAC] 事件处理器'click'应命名为'onClick'
[PRAC] 工具文件放在错误的文件夹
[PRAC] 误导性的变量名造成困惑
```

#### PR描述 (PR)

**定义**：PR描述应符合团队指南。

**检查清单**：
- [ ] PR描述清晰简洁
- [ ] 链接设计文档（如适用）
- [ ] 链接相关票据/问题
- [ ] 记录API变更
- [ ] 列出测试点
- [ ] 突出显示破坏性变更

**示例**：
```
[PR] 缺少设计文档链接
[PR] 未描述测试点
[PR] 未突出显示破坏性变更
```

---

## PR提交检查清单

提交PR前，请确保：

1. [ ] **代码遵循指南**：良好的命名、高内聚、低耦合、最少重复
2. [ ] **完成自审**：差异尽可能小
3. [ ] **复杂代码有注释**：特别是难以理解的部分
4. [ ] **日志包含上下文**：ID、reqId等
5. [ ] **PR描述完整**：包含所有必要的链接
6. [ ] **文档已更新**：做出相应的变更
7. [ ] **测试已添加/更新**：证明修复有效或功能正常
8. [ ] **本地所有测试通过**：新测试和现有测试
9. [ ] **依赖变更已合并**：下游模块已更新

---

## 使用指南

### 对于审查者

1. **系统性审查**：按分类检查项目，避免遗漏
2. **优先级排序**：首先关注关键和高优先级问题
3. **明确标注**：使用分类代码如`[LOGI]`、`[SEC]`
4. **提供建议**：不仅指出问题，还要建议改进方案

### 对于GitHub Copilot

协助代码审查时：
1. 识别问题时引用分类代码
2. 解释问题及其分类
3. 建议具体修复方案
4. 考虑每个代码段的多个分类

### 对于开发者

1. **自查**：提交PR前使用此清单
2. **理解分类**：了解不同问题类型的严重程度
3. **持续改进**：根据反馈改进编码习惯

### 对于团队

1. **定制化**：根据项目需求调整优先级和检查项
2. **数据追踪**：监控问题频率以识别改进领域
3. **培训材料**：用于新人入职和技能发展

---

## 参考资料

- [Google代码审查指南](https://google.github.io/eng-practices/review/reviewer/looking-for.html)
- 内部代码规范
- 安全最佳实践

---

*最后更新：2026-01-22*
